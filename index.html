<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Graffiti Pro - 3D Liquid Edition</title>
    
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>

    <style>
        body { margin: 0; background: #000; overflow: hidden; }
        .container { position: relative; width: 100vw; height: 100vh; }

        /* --- LOGO: Top Middle --- */
        .top-logo {
            position: absolute;
            top: 30px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            max-height: 70px;
            pointer-events: none;
            border: none;
        }

        .video_input {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            object-fit: cover; transform: scaleX(-1);
            opacity: 1;
        }

        /* Applying the 3D Liquid SVG Filter to the Canvas */
        #art_canvas { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 2; 
            filter: url('#gooey-3d'); /* Connects to the SVG filter below */
        }
        
        #three_canvas { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 3; pointer-events: none; 
        }

        #status {
            position: absolute; bottom: 20px; left: 20px;
            color: rgba(255,255,255,0.3); font-family: monospace; font-size: 10px;
            z-index: 10;
        }

        .paint-meter {
            position: absolute;
            top: 30px;
            left: 30px;
            width: 220px;
            height: 18px;
            border: 1px solid rgba(255, 255, 255, 0.35);
            border-radius: 999px;
            background: rgba(255, 255, 255, 0.08);
            overflow: hidden;
            z-index: 20;
        }

        .paint-meter__fill {
            height: 100%;
            width: 100%;
            background: linear-gradient(90deg, #35ffb3, #00d4ff);
            transition: width 0.08s linear;
        }

        .paint-meter__label {
            position: absolute;
            top: -22px;
            left: 0;
            font-family: monospace;
            font-size: 11px;
            color: rgba(255, 255, 255, 0.7);
        }

        .reset-overlay {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.7);
            z-index: 30;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
        }

        .reset-overlay.is-visible {
            opacity: 1;
            pointer-events: auto;
        }

        .reset-card {
            background: rgba(20, 20, 20, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            padding: 24px 28px;
            text-align: center;
            color: #fff;
            font-family: monospace;
        }

        .reset-card button {
            margin-top: 16px;
            padding: 8px 18px;
            border-radius: 999px;
            border: none;
            background: #00d4ff;
            color: #000;
            font-weight: bold;
            cursor: pointer;
        }

        /* SVG Filter Definition (Hidden) */
        svg { width: 0; height: 0; position: absolute; }
    </style>
</head>
<body data-spray-sound-url="splat.mp3" data-spray-sound-volume="0.45" data-paint-capacity="100" data-paint-drain-rate="0.7">

    <!-- 3D LIQUID SVG FILTER -->
    <svg>
      <defs>
        <filter id="gooey-3d">
          <!-- Gooey Melding Effect -->
          <feGaussianBlur in="SourceGraphic" stdDeviation="10" result="blur" />
          <feColorMatrix in="blur" mode="matrix" values="1 0 0 0 0  0 1 0 0 0  0 0 1 0 0  0 0 0 19 -9" result="goo" />
          
          <!-- 3D Specular Highlight (Wet/Glossy Look) -->
          <feSpecularLighting in="goo" surfaceScale="5" specularConstant="1" specularExponent="30" lighting-color="#ffffff" result="specular">
            <fePointLight x="500" y="-500" z="300" />
          </feSpecularLighting>
          
          <feComposite in="specular" in2="goo" operator="in" result="specularOut" />
          <feComposite in="goo" in2="specularOut" operator="arithmetic" k1="0" k2="1" k3="1" k4="0" />
        </filter>
      </defs>
    </svg>

    <div class="container">
        <!-- Replace with your PNG logo file path -->
        <img src="logo.png" alt="Logo" class="top-logo">

        <div class="paint-meter" aria-label="Paint meter">
            <div class="paint-meter__label">PAINT</div>
            <div class="paint-meter__fill"></div>
        </div>

        <video class="video_input"></video>
        <canvas id="art_canvas"></canvas>
        <canvas id="three_canvas"></canvas> 
        
        <div id="status">INITIALIZING TRACKING...</div>

        <div class="reset-overlay" id="reset_overlay">
            <div class="reset-card">
                <div>PAINT IS EMPTY.</div>
                <div>START OVER?</div>
                <button type="button" id="reset_button">RESET</button>
            </div>
        </div>
    </div>

    <script>
        const videoElement = document.querySelector('.video_input');
        const artCanvas = document.getElementById('art_canvas');
        const artCtx = artCanvas.getContext('2d');
        const statusText = document.getElementById('status');
        const paintMeterFill = document.querySelector('.paint-meter__fill');
        const resetOverlay = document.getElementById('reset_overlay');
        const resetButton = document.getElementById('reset_button');
        
        const SPRAY_RADIUS = 35; 
        const CAN_SCALE = .7;
        const NOZZLE_OFFSET_PX = 150; 

        const SPRAY_SOUND_URL = document.body.dataset.spraySoundUrl || '';
        const SPRAY_SOUND_VOLUME = Number(document.body.dataset.spraySoundVolume || 0.45);
        const PAINT_CAPACITY = Number(document.body.dataset.paintCapacity || 100);
        const PAINT_DRAIN_RATE = Number(document.body.dataset.paintDrainRate || 0.7);
        let sprayAudio = null;
        let isSpraying = false;
        
        let lastX = null, lastY = null;
        let drips = [];
        const getPaintCapacity = () => (Number.isFinite(PAINT_CAPACITY) && PAINT_CAPACITY > 0 ? PAINT_CAPACITY : 100);
        const getDrainRate = () => (Number.isFinite(PAINT_DRAIN_RATE) && PAINT_DRAIN_RATE > 0 ? PAINT_DRAIN_RATE : 0.7);
        let paintRemaining = getPaintCapacity();
        let isOutOfPaint = false;

        function updatePaintMeter() {
            const safeCapacity = getPaintCapacity();
            const percentage = Math.max(0, Math.min(1, paintRemaining / safeCapacity));
            paintMeterFill.style.width = `${percentage * 100}%`;
        }

        function setOutOfPaintState(outOfPaint) {
            isOutOfPaint = outOfPaint;
            resetOverlay.classList.toggle('is-visible', outOfPaint);
            if (outOfPaint) {
                stopSpraySound();
            }
        }

        function resetPaintSession() {
            paintRemaining = getPaintCapacity();
            artCtx.clearRect(0, 0, artCanvas.width, artCanvas.height);
            drips = [];
            lastX = null;
            lastY = null;
            setOutOfPaintState(false);
            updatePaintMeter();
        }

        if (SPRAY_SOUND_URL) {
            sprayAudio = new Audio(SPRAY_SOUND_URL);
            sprayAudio.loop = true;
            sprayAudio.preload = "auto";
            sprayAudio.volume = Number.isFinite(SPRAY_SOUND_VOLUME) ? SPRAY_SOUND_VOLUME : 0.45;
        }

        function startSpraySound() {
            if (!sprayAudio || isSpraying) return;
            isSpraying = true;
            sprayAudio.currentTime = 0;
            sprayAudio.play().catch(() => {});
        }

        function stopSpraySound() {
            if (!sprayAudio || !isSpraying) return;
            isSpraying = false;
            sprayAudio.pause();
            sprayAudio.currentTime = 0;
        }

        function resize() {
            const w = window.innerWidth;
            const h = window.innerHeight;

            artCanvas.width = w;
            artCanvas.height = h;

            renderer.setSize(w, h);
            camera.left = w / -2;
            camera.right = w / 2;
            camera.top = h / 2;
            camera.bottom = h / -2;
            camera.updateProjectionMatrix();
        }
        window.addEventListener('resize', resize);

        // --- THREE.JS SCENE ---
        const threeCanvas = document.getElementById('three_canvas');
        const renderer = new THREE.WebGLRenderer({ canvas: threeCanvas, alpha: true, antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        
        const scene = new THREE.Scene();
        const camera = new THREE.OrthographicCamera(
            window.innerWidth / -2, window.innerWidth / 2,
            window.innerHeight / 2, window.innerHeight / -2,
            1, 2000
        );
        camera.position.z = 1000;

        scene.add(new THREE.AmbientLight(0xffffff, 0.9));
        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(50, 100, 50);
        scene.add(dirLight);

        const canGroup = new THREE.Group();
        canGroup.scale.set(CAN_SCALE, CAN_SCALE, CAN_SCALE);
        scene.add(canGroup);

        let nozzleAnchor = null;
        const nozzleWorldPos = new THREE.Vector3();

        const loader = new THREE.GLTFLoader();
        loader.load('penis.glb', 
            (gltf) => {
                const model = gltf.scene;
                model.scale.set(65, 65, 65);
                model.rotation.y = Math.PI;
                canGroup.add(model);

                nozzleAnchor = model.getObjectByName('output');

                if (!nozzleAnchor) {
                    nozzleAnchor = new THREE.Object3D();
                    nozzleAnchor.position.set(0, 80, 0);
                    model.add(nozzleAnchor);
                }
            },
            undefined,
            () => {
                const bodyGeo = new THREE.CylinderGeometry(20, 20, 220, 32);
                const bodyMat = new THREE.MeshStandardMaterial({ color: 0x222222, metalness: 0.8 });
                const cylinder = new THREE.Mesh(bodyGeo, bodyMat);
                cylinder.position.y = -60;
                canGroup.add(cylinder);

                const capGeo = new THREE.CylinderGeometry(20, 20, 12, 32);
                const capMat = new THREE.MeshStandardMaterial({ color: 0xcccccc });
                const cap = new THREE.Mesh(capGeo, capMat);
                cap.position.y = 55;
                canGroup.add(cap);

                nozzleAnchor = new THREE.Object3D();
                nozzleAnchor.position.set(0, 70, 0);
                canGroup.add(nozzleAnchor);
            }
        );

        // --- 3D LIQUID ENGINE ---
        function sprayGoo(x, y, radius) {
            artCtx.fillStyle = "white";
            
            if (lastX !== null) {
                const dist = Math.hypot(x - lastX, y - lastY);
                const steps = Math.max(1, Math.floor(dist / 3));
                
                for(let i=0; i<steps; i++) {
                    const bx = lastX + (x - lastX) * (i/steps);
                    const by = lastY + (y - lastY) * (i/steps);
                    
                    artCtx.beginPath();
                    // Draw main body
                    artCtx.arc(bx, by, radius, 0, Math.PI*2);
                    artCtx.fill();
                }
            }

            // Probability of a drip
            if (Math.random() > 0.93) {
                drips.push({
                    x: x + (Math.random() - 0.5) * radius,
                    y: y,
                    speed: 1.2 + Math.random() * 2,
                    r: radius * 0.45,
                    life: 200
                });
            }
        }

        function updateDrips() {
            artCtx.fillStyle = "white";
            for (let i = drips.length - 1; i >= 0; i--) {
                const d = drips[i];
                artCtx.beginPath();
                artCtx.arc(d.x, d.y, d.r, 0, Math.PI * 2);
                artCtx.fill();
                d.y += d.speed;
                d.life--;
                d.r *= 0.994;
                if (d.life <= 0 || d.r < 1) drips.splice(i, 1);
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            updateDrips();
            renderer.render(scene, camera);
        }

        // --- TRACKING ---
        function onResults(results) {
            statusText.innerText = results.multiHandLandmarks.length > 0 ? "" : "HAND NOT DETECTED";

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                const w = window.innerWidth;
                const h = window.innerHeight;

                const ix = (1 - landmarks[5].x) * w; 
                const iy = landmarks[5].y * h;
                const wx = (1 - landmarks[0].x) * w;
                const wy = landmarks[0].y * h;
                const mx = (1 - landmarks[9].x) * w;
                const my = landmarks[9].y * h;

                const dirX = mx - wx; const dirY = my - wy;
                const length = Math.hypot(dirX, dirY);
                const unitX = dirX / length; const unitY = dirY / length;

                canGroup.position.x = ix - w / 2;
                canGroup.position.y = -iy + h / 2;
                canGroup.rotation.z = -(Math.atan2(dirY, dirX) + Math.PI / 2);

                const isPinching = Math.hypot(
                    (landmarks[8].x - landmarks[4].x),
                    (landmarks[8].y - landmarks[4].y)
                ) < 0.07;

                if (isPinching && !isOutOfPaint) {
                    let paintX = ix + (unitX * NOZZLE_OFFSET_PX);
                    let paintY = iy + (unitY * NOZZLE_OFFSET_PX);

                    if (nozzleAnchor) {
                        nozzleAnchor.getWorldPosition(nozzleWorldPos);
                        paintX = nozzleWorldPos.x + w / 2;
                        paintY = -nozzleWorldPos.y + h / 2;
                    }

                    sprayGoo(paintX, paintY, SPRAY_RADIUS);
                    lastX = paintX; lastY = paintY;
                    canGroup.scale.set(CAN_SCALE * 0.96, CAN_SCALE * 0.96, CAN_SCALE * 0.96);
                    startSpraySound();
                    paintRemaining = Math.max(0, paintRemaining - getDrainRate());
                    updatePaintMeter();

                    if (paintRemaining <= 0) {
                        setOutOfPaintState(true);
                    }
                } else {
                    lastX = null; lastY = null;
                    canGroup.scale.set(CAN_SCALE, CAN_SCALE, CAN_SCALE);
                    stopSpraySound();
                }
            } else {
                stopSpraySound();
            }
        }

        resize();
        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.8, minTrackingConfidence: 0.8 });
        hands.onResults(onResults);

        const cameraInst = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 1280, height: 720
        });
        
        cameraInst.start();
        updatePaintMeter();
        resetButton.addEventListener('click', resetPaintSession);
        resetOverlay.addEventListener('click', (event) => {
            if (event.target === resetOverlay) {
                resetPaintSession();
            }
        });
        animate();
    </script>
</body>
</html>
